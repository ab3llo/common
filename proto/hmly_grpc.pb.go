// Proto3 syntax definition for the HMLY (Home Life) family management API.
// This file defines the gRPC services and message types for managing
// households, members, meals, and events.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.0
// source: hmly.proto

// Package namespace for all services and messages

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	HouseholdService_CreateHousehold_FullMethodName = "/api.HouseholdService/CreateHousehold"
	HouseholdService_GetHousehold_FullMethodName    = "/api.HouseholdService/GetHousehold"
	HouseholdService_GetHouseholds_FullMethodName   = "/api.HouseholdService/GetHouseholds"
	HouseholdService_UpdateHousehold_FullMethodName = "/api.HouseholdService/UpdateHousehold"
	HouseholdService_DeleteHousehold_FullMethodName = "/api.HouseholdService/DeleteHousehold"
)

// HouseholdServiceClient is the client API for HouseholdService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// HouseholdService manages household entities within the HMLY system.
// A household represents a family unit or group of people living together.
type HouseholdServiceClient interface {
	// CreateHousehold creates a new household with the specified name.
	// Returns the newly created household with its assigned ID.
	CreateHousehold(ctx context.Context, in *CreateHouseholdRequest, opts ...grpc.CallOption) (*HouseholdResponse, error)
	// GetHousehold retrieves a specific household by its unique ID.
	// Returns the household details if found.
	GetHousehold(ctx context.Context, in *GetHouseholdRequest, opts ...grpc.CallOption) (*HouseholdResponse, error)
	// GetHouseholds retrieves a paginated list of households.
	// Supports pagination through offset and limit parameters.
	GetHouseholds(ctx context.Context, in *GetHouseHoldsRequest, opts ...grpc.CallOption) (*HouseholdsResponse, error)
	// UpdateHousehold modifies an existing household's properties.
	// Updates the household identified by the provided ID.
	UpdateHousehold(ctx context.Context, in *UpdateHouseholdRequest, opts ...grpc.CallOption) (*HouseholdResponse, error)
	// DeleteHousehold removes a household from the system.
	// This operation may cascade to related entities.
	DeleteHousehold(ctx context.Context, in *GetHouseholdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type householdServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHouseholdServiceClient(cc grpc.ClientConnInterface) HouseholdServiceClient {
	return &householdServiceClient{cc}
}

func (c *householdServiceClient) CreateHousehold(ctx context.Context, in *CreateHouseholdRequest, opts ...grpc.CallOption) (*HouseholdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HouseholdResponse)
	err := c.cc.Invoke(ctx, HouseholdService_CreateHousehold_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *householdServiceClient) GetHousehold(ctx context.Context, in *GetHouseholdRequest, opts ...grpc.CallOption) (*HouseholdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HouseholdResponse)
	err := c.cc.Invoke(ctx, HouseholdService_GetHousehold_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *householdServiceClient) GetHouseholds(ctx context.Context, in *GetHouseHoldsRequest, opts ...grpc.CallOption) (*HouseholdsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HouseholdsResponse)
	err := c.cc.Invoke(ctx, HouseholdService_GetHouseholds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *householdServiceClient) UpdateHousehold(ctx context.Context, in *UpdateHouseholdRequest, opts ...grpc.CallOption) (*HouseholdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HouseholdResponse)
	err := c.cc.Invoke(ctx, HouseholdService_UpdateHousehold_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *householdServiceClient) DeleteHousehold(ctx context.Context, in *GetHouseholdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, HouseholdService_DeleteHousehold_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HouseholdServiceServer is the server API for HouseholdService service.
// All implementations must embed UnimplementedHouseholdServiceServer
// for forward compatibility.
//
// HouseholdService manages household entities within the HMLY system.
// A household represents a family unit or group of people living together.
type HouseholdServiceServer interface {
	// CreateHousehold creates a new household with the specified name.
	// Returns the newly created household with its assigned ID.
	CreateHousehold(context.Context, *CreateHouseholdRequest) (*HouseholdResponse, error)
	// GetHousehold retrieves a specific household by its unique ID.
	// Returns the household details if found.
	GetHousehold(context.Context, *GetHouseholdRequest) (*HouseholdResponse, error)
	// GetHouseholds retrieves a paginated list of households.
	// Supports pagination through offset and limit parameters.
	GetHouseholds(context.Context, *GetHouseHoldsRequest) (*HouseholdsResponse, error)
	// UpdateHousehold modifies an existing household's properties.
	// Updates the household identified by the provided ID.
	UpdateHousehold(context.Context, *UpdateHouseholdRequest) (*HouseholdResponse, error)
	// DeleteHousehold removes a household from the system.
	// This operation may cascade to related entities.
	DeleteHousehold(context.Context, *GetHouseholdRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedHouseholdServiceServer()
}

// UnimplementedHouseholdServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHouseholdServiceServer struct{}

func (UnimplementedHouseholdServiceServer) CreateHousehold(context.Context, *CreateHouseholdRequest) (*HouseholdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateHousehold not implemented")
}
func (UnimplementedHouseholdServiceServer) GetHousehold(context.Context, *GetHouseholdRequest) (*HouseholdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHousehold not implemented")
}
func (UnimplementedHouseholdServiceServer) GetHouseholds(context.Context, *GetHouseHoldsRequest) (*HouseholdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHouseholds not implemented")
}
func (UnimplementedHouseholdServiceServer) UpdateHousehold(context.Context, *UpdateHouseholdRequest) (*HouseholdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHousehold not implemented")
}
func (UnimplementedHouseholdServiceServer) DeleteHousehold(context.Context, *GetHouseholdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHousehold not implemented")
}
func (UnimplementedHouseholdServiceServer) mustEmbedUnimplementedHouseholdServiceServer() {}
func (UnimplementedHouseholdServiceServer) testEmbeddedByValue()                          {}

// UnsafeHouseholdServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HouseholdServiceServer will
// result in compilation errors.
type UnsafeHouseholdServiceServer interface {
	mustEmbedUnimplementedHouseholdServiceServer()
}

func RegisterHouseholdServiceServer(s grpc.ServiceRegistrar, srv HouseholdServiceServer) {
	// If the following call pancis, it indicates UnimplementedHouseholdServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HouseholdService_ServiceDesc, srv)
}

func _HouseholdService_CreateHousehold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateHouseholdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HouseholdServiceServer).CreateHousehold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HouseholdService_CreateHousehold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HouseholdServiceServer).CreateHousehold(ctx, req.(*CreateHouseholdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HouseholdService_GetHousehold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHouseholdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HouseholdServiceServer).GetHousehold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HouseholdService_GetHousehold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HouseholdServiceServer).GetHousehold(ctx, req.(*GetHouseholdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HouseholdService_GetHouseholds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHouseHoldsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HouseholdServiceServer).GetHouseholds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HouseholdService_GetHouseholds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HouseholdServiceServer).GetHouseholds(ctx, req.(*GetHouseHoldsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HouseholdService_UpdateHousehold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHouseholdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HouseholdServiceServer).UpdateHousehold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HouseholdService_UpdateHousehold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HouseholdServiceServer).UpdateHousehold(ctx, req.(*UpdateHouseholdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HouseholdService_DeleteHousehold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHouseholdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HouseholdServiceServer).DeleteHousehold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HouseholdService_DeleteHousehold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HouseholdServiceServer).DeleteHousehold(ctx, req.(*GetHouseholdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HouseholdService_ServiceDesc is the grpc.ServiceDesc for HouseholdService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HouseholdService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.HouseholdService",
	HandlerType: (*HouseholdServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateHousehold",
			Handler:    _HouseholdService_CreateHousehold_Handler,
		},
		{
			MethodName: "GetHousehold",
			Handler:    _HouseholdService_GetHousehold_Handler,
		},
		{
			MethodName: "GetHouseholds",
			Handler:    _HouseholdService_GetHouseholds_Handler,
		},
		{
			MethodName: "UpdateHousehold",
			Handler:    _HouseholdService_UpdateHousehold_Handler,
		},
		{
			MethodName: "DeleteHousehold",
			Handler:    _HouseholdService_DeleteHousehold_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hmly.proto",
}

const (
	MemberService_CreateMember_FullMethodName = "/api.MemberService/CreateMember"
	MemberService_GetMember_FullMethodName    = "/api.MemberService/GetMember"
	MemberService_GetMembers_FullMethodName   = "/api.MemberService/GetMembers"
	MemberService_UpdateMember_FullMethodName = "/api.MemberService/UpdateMember"
	MemberService_DeleteMember_FullMethodName = "/api.MemberService/DeleteMember"
)

// MemberServiceClient is the client API for MemberService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MemberService manages membership relationships between users and households.
// Members represent the association of users with specific households.
type MemberServiceClient interface {
	// CreateMember adds a user to a household as a member.
	// Creates the membership relationship between user and household.
	CreateMember(ctx context.Context, in *CreateMemberRequest, opts ...grpc.CallOption) (*MemberResponse, error)
	// GetMember retrieves a specific member by their unique ID.
	// Returns the member details including household and user associations.
	GetMember(ctx context.Context, in *GetMemberRequest, opts ...grpc.CallOption) (*MemberResponse, error)
	// GetMembers retrieves all members belonging to a specific household.
	// Returns a list of all users who are members of the household.
	GetMembers(ctx context.Context, in *GetMembersRequest, opts ...grpc.CallOption) (*MembersResponse, error)
	// UpdateMember modifies an existing member's association.
	// Can change the household or user ID for the membership.
	UpdateMember(ctx context.Context, in *UpdateMemberRequest, opts ...grpc.CallOption) (*MemberResponse, error)
	// DeleteMember removes a user's membership from a household.
	// Breaks the association between the user and household.
	DeleteMember(ctx context.Context, in *GetMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type memberServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMemberServiceClient(cc grpc.ClientConnInterface) MemberServiceClient {
	return &memberServiceClient{cc}
}

func (c *memberServiceClient) CreateMember(ctx context.Context, in *CreateMemberRequest, opts ...grpc.CallOption) (*MemberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemberResponse)
	err := c.cc.Invoke(ctx, MemberService_CreateMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memberServiceClient) GetMember(ctx context.Context, in *GetMemberRequest, opts ...grpc.CallOption) (*MemberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemberResponse)
	err := c.cc.Invoke(ctx, MemberService_GetMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memberServiceClient) GetMembers(ctx context.Context, in *GetMembersRequest, opts ...grpc.CallOption) (*MembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MembersResponse)
	err := c.cc.Invoke(ctx, MemberService_GetMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memberServiceClient) UpdateMember(ctx context.Context, in *UpdateMemberRequest, opts ...grpc.CallOption) (*MemberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemberResponse)
	err := c.cc.Invoke(ctx, MemberService_UpdateMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memberServiceClient) DeleteMember(ctx context.Context, in *GetMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, MemberService_DeleteMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MemberServiceServer is the server API for MemberService service.
// All implementations must embed UnimplementedMemberServiceServer
// for forward compatibility.
//
// MemberService manages membership relationships between users and households.
// Members represent the association of users with specific households.
type MemberServiceServer interface {
	// CreateMember adds a user to a household as a member.
	// Creates the membership relationship between user and household.
	CreateMember(context.Context, *CreateMemberRequest) (*MemberResponse, error)
	// GetMember retrieves a specific member by their unique ID.
	// Returns the member details including household and user associations.
	GetMember(context.Context, *GetMemberRequest) (*MemberResponse, error)
	// GetMembers retrieves all members belonging to a specific household.
	// Returns a list of all users who are members of the household.
	GetMembers(context.Context, *GetMembersRequest) (*MembersResponse, error)
	// UpdateMember modifies an existing member's association.
	// Can change the household or user ID for the membership.
	UpdateMember(context.Context, *UpdateMemberRequest) (*MemberResponse, error)
	// DeleteMember removes a user's membership from a household.
	// Breaks the association between the user and household.
	DeleteMember(context.Context, *GetMemberRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedMemberServiceServer()
}

// UnimplementedMemberServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMemberServiceServer struct{}

func (UnimplementedMemberServiceServer) CreateMember(context.Context, *CreateMemberRequest) (*MemberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMember not implemented")
}
func (UnimplementedMemberServiceServer) GetMember(context.Context, *GetMemberRequest) (*MemberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMember not implemented")
}
func (UnimplementedMemberServiceServer) GetMembers(context.Context, *GetMembersRequest) (*MembersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMembers not implemented")
}
func (UnimplementedMemberServiceServer) UpdateMember(context.Context, *UpdateMemberRequest) (*MemberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMember not implemented")
}
func (UnimplementedMemberServiceServer) DeleteMember(context.Context, *GetMemberRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMember not implemented")
}
func (UnimplementedMemberServiceServer) mustEmbedUnimplementedMemberServiceServer() {}
func (UnimplementedMemberServiceServer) testEmbeddedByValue()                       {}

// UnsafeMemberServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MemberServiceServer will
// result in compilation errors.
type UnsafeMemberServiceServer interface {
	mustEmbedUnimplementedMemberServiceServer()
}

func RegisterMemberServiceServer(s grpc.ServiceRegistrar, srv MemberServiceServer) {
	// If the following call pancis, it indicates UnimplementedMemberServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MemberService_ServiceDesc, srv)
}

func _MemberService_CreateMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemberServiceServer).CreateMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemberService_CreateMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemberServiceServer).CreateMember(ctx, req.(*CreateMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemberService_GetMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemberServiceServer).GetMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemberService_GetMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemberServiceServer).GetMember(ctx, req.(*GetMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemberService_GetMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemberServiceServer).GetMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemberService_GetMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemberServiceServer).GetMembers(ctx, req.(*GetMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemberService_UpdateMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemberServiceServer).UpdateMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemberService_UpdateMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemberServiceServer).UpdateMember(ctx, req.(*UpdateMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemberService_DeleteMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemberServiceServer).DeleteMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemberService_DeleteMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemberServiceServer).DeleteMember(ctx, req.(*GetMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MemberService_ServiceDesc is the grpc.ServiceDesc for MemberService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MemberService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.MemberService",
	HandlerType: (*MemberServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMember",
			Handler:    _MemberService_CreateMember_Handler,
		},
		{
			MethodName: "GetMember",
			Handler:    _MemberService_GetMember_Handler,
		},
		{
			MethodName: "GetMembers",
			Handler:    _MemberService_GetMembers_Handler,
		},
		{
			MethodName: "UpdateMember",
			Handler:    _MemberService_UpdateMember_Handler,
		},
		{
			MethodName: "DeleteMember",
			Handler:    _MemberService_DeleteMember_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hmly.proto",
}

const (
	MealService_CreateMeal_FullMethodName = "/api.MealService/CreateMeal"
	MealService_GetMeal_FullMethodName    = "/api.MealService/GetMeal"
	MealService_GetMeals_FullMethodName   = "/api.MealService/GetMeals"
	MealService_UpdateMeal_FullMethodName = "/api.MealService/UpdateMeal"
	MealService_DeleteMeal_FullMethodName = "/api.MealService/DeleteMeal"
)

// MealServiceClient is the client API for MealService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MealService manages meal planning and tracking within households.
// Meals represent food-related events, recipes, or planned dining activities.
type MealServiceClient interface {
	// CreateMeal adds a new meal to a household's meal plan.
	// Associates the meal with a specific household for organization.
	CreateMeal(ctx context.Context, in *CreateMealRequest, opts ...grpc.CallOption) (*MealResponse, error)
	// GetMeal retrieves a specific meal by its unique ID.
	// Returns detailed information about the meal including household association.
	GetMeal(ctx context.Context, in *GetMealRequest, opts ...grpc.CallOption) (*MealResponse, error)
	// GetMeals retrieves all meals for a specific household.
	// Returns the complete meal plan for the household.
	GetMeals(ctx context.Context, in *GetMealsRequest, opts ...grpc.CallOption) (*MealsResponse, error)
	// UpdateMeal modifies an existing meal's details.
	// Can change meal name, household association, or other properties.
	UpdateMeal(ctx context.Context, in *UpdateMealRequest, opts ...grpc.CallOption) (*MealResponse, error)
	// DeleteMeal removes a meal from the household's meal plan.
	// Permanently deletes the meal record from the system.
	DeleteMeal(ctx context.Context, in *GetMealRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mealServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMealServiceClient(cc grpc.ClientConnInterface) MealServiceClient {
	return &mealServiceClient{cc}
}

func (c *mealServiceClient) CreateMeal(ctx context.Context, in *CreateMealRequest, opts ...grpc.CallOption) (*MealResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MealResponse)
	err := c.cc.Invoke(ctx, MealService_CreateMeal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mealServiceClient) GetMeal(ctx context.Context, in *GetMealRequest, opts ...grpc.CallOption) (*MealResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MealResponse)
	err := c.cc.Invoke(ctx, MealService_GetMeal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mealServiceClient) GetMeals(ctx context.Context, in *GetMealsRequest, opts ...grpc.CallOption) (*MealsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MealsResponse)
	err := c.cc.Invoke(ctx, MealService_GetMeals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mealServiceClient) UpdateMeal(ctx context.Context, in *UpdateMealRequest, opts ...grpc.CallOption) (*MealResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MealResponse)
	err := c.cc.Invoke(ctx, MealService_UpdateMeal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mealServiceClient) DeleteMeal(ctx context.Context, in *GetMealRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, MealService_DeleteMeal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MealServiceServer is the server API for MealService service.
// All implementations must embed UnimplementedMealServiceServer
// for forward compatibility.
//
// MealService manages meal planning and tracking within households.
// Meals represent food-related events, recipes, or planned dining activities.
type MealServiceServer interface {
	// CreateMeal adds a new meal to a household's meal plan.
	// Associates the meal with a specific household for organization.
	CreateMeal(context.Context, *CreateMealRequest) (*MealResponse, error)
	// GetMeal retrieves a specific meal by its unique ID.
	// Returns detailed information about the meal including household association.
	GetMeal(context.Context, *GetMealRequest) (*MealResponse, error)
	// GetMeals retrieves all meals for a specific household.
	// Returns the complete meal plan for the household.
	GetMeals(context.Context, *GetMealsRequest) (*MealsResponse, error)
	// UpdateMeal modifies an existing meal's details.
	// Can change meal name, household association, or other properties.
	UpdateMeal(context.Context, *UpdateMealRequest) (*MealResponse, error)
	// DeleteMeal removes a meal from the household's meal plan.
	// Permanently deletes the meal record from the system.
	DeleteMeal(context.Context, *GetMealRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedMealServiceServer()
}

// UnimplementedMealServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMealServiceServer struct{}

func (UnimplementedMealServiceServer) CreateMeal(context.Context, *CreateMealRequest) (*MealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMeal not implemented")
}
func (UnimplementedMealServiceServer) GetMeal(context.Context, *GetMealRequest) (*MealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMeal not implemented")
}
func (UnimplementedMealServiceServer) GetMeals(context.Context, *GetMealsRequest) (*MealsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMeals not implemented")
}
func (UnimplementedMealServiceServer) UpdateMeal(context.Context, *UpdateMealRequest) (*MealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMeal not implemented")
}
func (UnimplementedMealServiceServer) DeleteMeal(context.Context, *GetMealRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMeal not implemented")
}
func (UnimplementedMealServiceServer) mustEmbedUnimplementedMealServiceServer() {}
func (UnimplementedMealServiceServer) testEmbeddedByValue()                     {}

// UnsafeMealServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MealServiceServer will
// result in compilation errors.
type UnsafeMealServiceServer interface {
	mustEmbedUnimplementedMealServiceServer()
}

func RegisterMealServiceServer(s grpc.ServiceRegistrar, srv MealServiceServer) {
	// If the following call pancis, it indicates UnimplementedMealServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MealService_ServiceDesc, srv)
}

func _MealService_CreateMeal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MealServiceServer).CreateMeal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MealService_CreateMeal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MealServiceServer).CreateMeal(ctx, req.(*CreateMealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MealService_GetMeal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MealServiceServer).GetMeal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MealService_GetMeal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MealServiceServer).GetMeal(ctx, req.(*GetMealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MealService_GetMeals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMealsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MealServiceServer).GetMeals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MealService_GetMeals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MealServiceServer).GetMeals(ctx, req.(*GetMealsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MealService_UpdateMeal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MealServiceServer).UpdateMeal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MealService_UpdateMeal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MealServiceServer).UpdateMeal(ctx, req.(*UpdateMealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MealService_DeleteMeal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MealServiceServer).DeleteMeal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MealService_DeleteMeal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MealServiceServer).DeleteMeal(ctx, req.(*GetMealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MealService_ServiceDesc is the grpc.ServiceDesc for MealService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MealService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.MealService",
	HandlerType: (*MealServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMeal",
			Handler:    _MealService_CreateMeal_Handler,
		},
		{
			MethodName: "GetMeal",
			Handler:    _MealService_GetMeal_Handler,
		},
		{
			MethodName: "GetMeals",
			Handler:    _MealService_GetMeals_Handler,
		},
		{
			MethodName: "UpdateMeal",
			Handler:    _MealService_UpdateMeal_Handler,
		},
		{
			MethodName: "DeleteMeal",
			Handler:    _MealService_DeleteMeal_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hmly.proto",
}

const (
	EventService_CreateEvent_FullMethodName = "/api.EventService/CreateEvent"
	EventService_GetEvent_FullMethodName    = "/api.EventService/GetEvent"
	EventService_GetEvents_FullMethodName   = "/api.EventService/GetEvents"
	EventService_UpdateEvent_FullMethodName = "/api.EventService/UpdateEvent"
	EventService_DeleteEvent_FullMethodName = "/api.EventService/DeleteEvent"
)

// EventServiceClient is the client API for EventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// EventService manages scheduled events and activities within the HMLY system.
// Events can be associated with any entity type (households, meals, members, etc.)
// and support assignment to specific users with start/end date tracking.
type EventServiceClient interface {
	// CreateEvent schedules a new event in the system.
	// Events can be linked to any entity and assigned to specific users.
	CreateEvent(ctx context.Context, in *CreateEventRequest, opts ...grpc.CallOption) (*EventResponse, error)
	// GetEvent retrieves a specific event by its unique ID.
	// Returns complete event details including entity associations and assignments.
	GetEvent(ctx context.Context, in *GetEventRequest, opts ...grpc.CallOption) (*EventResponse, error)
	// GetEvents retrieves a filtered list of events.
	// Supports filtering by entity type and pagination through offset/limit.
	GetEvents(ctx context.Context, in *GetEventsRequest, opts ...grpc.CallOption) (*EventsResponse, error)
	// UpdateEvent modifies an existing event's properties.
	// Can update name, dates, assignments, or entity associations.
	UpdateEvent(ctx context.Context, in *UpdateEventRequest, opts ...grpc.CallOption) (*EventResponse, error)
	// DeleteEvent removes an event from the system.
	// Permanently deletes the event and all its associations.
	DeleteEvent(ctx context.Context, in *GetEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type eventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEventServiceClient(cc grpc.ClientConnInterface) EventServiceClient {
	return &eventServiceClient{cc}
}

func (c *eventServiceClient) CreateEvent(ctx context.Context, in *CreateEventRequest, opts ...grpc.CallOption) (*EventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventResponse)
	err := c.cc.Invoke(ctx, EventService_CreateEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) GetEvent(ctx context.Context, in *GetEventRequest, opts ...grpc.CallOption) (*EventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventResponse)
	err := c.cc.Invoke(ctx, EventService_GetEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) GetEvents(ctx context.Context, in *GetEventsRequest, opts ...grpc.CallOption) (*EventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventsResponse)
	err := c.cc.Invoke(ctx, EventService_GetEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) UpdateEvent(ctx context.Context, in *UpdateEventRequest, opts ...grpc.CallOption) (*EventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventResponse)
	err := c.cc.Invoke(ctx, EventService_UpdateEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) DeleteEvent(ctx context.Context, in *GetEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EventService_DeleteEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventServiceServer is the server API for EventService service.
// All implementations must embed UnimplementedEventServiceServer
// for forward compatibility.
//
// EventService manages scheduled events and activities within the HMLY system.
// Events can be associated with any entity type (households, meals, members, etc.)
// and support assignment to specific users with start/end date tracking.
type EventServiceServer interface {
	// CreateEvent schedules a new event in the system.
	// Events can be linked to any entity and assigned to specific users.
	CreateEvent(context.Context, *CreateEventRequest) (*EventResponse, error)
	// GetEvent retrieves a specific event by its unique ID.
	// Returns complete event details including entity associations and assignments.
	GetEvent(context.Context, *GetEventRequest) (*EventResponse, error)
	// GetEvents retrieves a filtered list of events.
	// Supports filtering by entity type and pagination through offset/limit.
	GetEvents(context.Context, *GetEventsRequest) (*EventsResponse, error)
	// UpdateEvent modifies an existing event's properties.
	// Can update name, dates, assignments, or entity associations.
	UpdateEvent(context.Context, *UpdateEventRequest) (*EventResponse, error)
	// DeleteEvent removes an event from the system.
	// Permanently deletes the event and all its associations.
	DeleteEvent(context.Context, *GetEventRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedEventServiceServer()
}

// UnimplementedEventServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEventServiceServer struct{}

func (UnimplementedEventServiceServer) CreateEvent(context.Context, *CreateEventRequest) (*EventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEvent not implemented")
}
func (UnimplementedEventServiceServer) GetEvent(context.Context, *GetEventRequest) (*EventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEvent not implemented")
}
func (UnimplementedEventServiceServer) GetEvents(context.Context, *GetEventsRequest) (*EventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEvents not implemented")
}
func (UnimplementedEventServiceServer) UpdateEvent(context.Context, *UpdateEventRequest) (*EventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEvent not implemented")
}
func (UnimplementedEventServiceServer) DeleteEvent(context.Context, *GetEventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteEvent not implemented")
}
func (UnimplementedEventServiceServer) mustEmbedUnimplementedEventServiceServer() {}
func (UnimplementedEventServiceServer) testEmbeddedByValue()                      {}

// UnsafeEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventServiceServer will
// result in compilation errors.
type UnsafeEventServiceServer interface {
	mustEmbedUnimplementedEventServiceServer()
}

func RegisterEventServiceServer(s grpc.ServiceRegistrar, srv EventServiceServer) {
	// If the following call pancis, it indicates UnimplementedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EventService_ServiceDesc, srv)
}

func _EventService_CreateEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).CreateEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_CreateEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).CreateEvent(ctx, req.(*CreateEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_GetEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).GetEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_GetEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).GetEvent(ctx, req.(*GetEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_GetEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).GetEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_GetEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).GetEvents(ctx, req.(*GetEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_UpdateEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).UpdateEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_UpdateEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).UpdateEvent(ctx, req.(*UpdateEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_DeleteEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).DeleteEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_DeleteEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).DeleteEvent(ctx, req.(*GetEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventService_ServiceDesc is the grpc.ServiceDesc for EventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.EventService",
	HandlerType: (*EventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEvent",
			Handler:    _EventService_CreateEvent_Handler,
		},
		{
			MethodName: "GetEvent",
			Handler:    _EventService_GetEvent_Handler,
		},
		{
			MethodName: "GetEvents",
			Handler:    _EventService_GetEvents_Handler,
		},
		{
			MethodName: "UpdateEvent",
			Handler:    _EventService_UpdateEvent_Handler,
		},
		{
			MethodName: "DeleteEvent",
			Handler:    _EventService_DeleteEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hmly.proto",
}
